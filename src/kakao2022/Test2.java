package kakao2022;

// 2.물감 구매하기

/* 라이언은 색칠 놀이를 하고 싶은 춘식에게 물감을 사주려고 합니다.
 * 물감가게는 색깔 별로 금액을 받습니다. 총 n가지 색의 물감을 판매하며, i(0<=i<n) 번째 물감 색깔의 가격은 cost[i] 원 입니다.
 * i번째 색깔을 구매하면 2^i 개 만큼 물감을 얻을수 있습니다.
 * 이때, 라이언이 가진 예산 x원으로 얻을수 있는 최대한 많은 양의 물감 개수를 구하세요.
 * 단, 얻은 물감의 개수가 (10^9+7) 개 이상인 경우, 얻은 물감의 개수 % (10^9+7) 개 만큼의 값을 반환합니다.(여기서 % 는 나머지 연산자를 의미)
 * 
 * Constraints(제한사항): 1<=n<=10^5, 1<=cost[i]<=10^5, 0<=x<10^9 <-- 이새끼 돈많네(10억인데..)
 * 
 * ------------------------------------------------------------------------------------------------
 * Ex1)
 * n=5;
 * cost = {10, 20, 14, 40, 50};
 * x=70;
 * 
 * 라이언이 살 수 있는 물감의 조합은 다음과 같습니다.
 * - 라이언이 0,1,2 번째 물감을 44원으로 구매하면 2^0 + 2^1 + 2^2 = 7개 
 * - 라이언이 0,4 번째 물감을 60원으로 구매하면 2^0 + 2^4 = 17개 
 * - 라이언이 1,4 번째 물감을 70원으로 구매하면 2^1 + 2^4 = 18개 
 * - 라이언이 2,4 번째 물감을 64원으로 구매하면 2^2 + 2^4 = 20개
 * 
 * 가능한 조합 중에서 가장 많은 양의 물감을 얻을수 있는 조합은 2,4 번째 물감을 64원으로 구매하여 
 * 20개 물감을 얻는 것입니다.
 * ------------------------------------------------------------------------------------------------
 * Ex2)
 * n=3;
 * cost = {3,4,1};
 * x=8;
 * 
 * 모든 물감 가격의 합이 라이언이 가진 예산 x 보다 적거나 같기에 모든 물감을 구매가능
 * 2^0 + 2^1 + 2^2 = 7개
 * ------------------------------------------------------------------------------------------------
 * Ex3)
 * n=5;
 * cost = {19,78,27,18,20};
 * x=25;
 * 
 * 마지막 색깔을 구매하면 최대 값인 2^4=16 개 물감을 구매가능
 * 
 * 
 */
// (10^9+7)=1000000007
// 2^0=1
// 2^1=2
// 2^2=4
// 2^3=8
// 2^4=16
// 2^5=32

/**
 DP 문제 하.. 이것도 쉬운 문제인데... 절었다..ㅆㅂ
//└ 아이템이 포한된 경우, 안포함된 경우로 계산

/*
 *  	0 1 2 3 4 5 7...70
	*     Φ  
	*     A  
	*    AB  
	*   ABC  
	*  ABCD
	* ABCDE
 */

public class Test2 {

	public static void main(String[] args) {
		

		// n = 물감의 갯수 
		// cost = 물감의 가격
		// x = 가진돈 
		
		 int n=5;
		 int cost[] = {10, 20, 14, 40, 50};
		 int x=70;
		 // 20 
		
//		 int n=3;
//		 int cost[] = {3,4,1};
//		 int x=8;
		 // 7
		
//		 int n=5;
//		 int cost[] = {19,78,27,18,20};
//		 int x=25;
		 // 16 
		
		System.out.println(solution(n, cost, x));

	}

	private static  int solution(int t, int[] cost, int limit) {
		int len = cost.length;
				
		int[] values = new int[len];
		for (int i = 0; i < cost.length; i++) {
			values[i] = (int) Math.pow(2, i);
		}		
		
		int[][] dp = new int[len+1][limit+1];
		
		for (int n = 1; n <= len; n++) {
			for (int c = 1; c <= limit; c++) {
				if(cost[n-1] <= c) {
					int value = values[n-1];
					dp[n][c] = Math.max(dp[n-1][c], dp[n-1][c - cost[n-1]] + value);
				}else {
					dp[n][c] = dp[n-1][c];
				}
			}
		}
		
		
		
		return dp[len][limit];
	}
	

}
