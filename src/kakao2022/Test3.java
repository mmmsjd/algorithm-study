package kakao2022;

// 3.빵 옮기기

/* 편의점 알바생 죠르디가 일렬로 나열된 n개의 상자 배열 box에 담긴 빵을 다시 나눠 담으려고 합니다.
 * 각 상자는 1부터 시작하는 양의 정수를 인덱스로 가집니다.
 * 죠르디는 다음과 같은 과정으로만 빵을 옮길수 있으며, 이과정은 몇차례건 가능합니다.
 * 
 * 다음
 * 1. 2<=i<=n 을 만족하는 i를 고릅니다. 
 * 2. 1<=x<=box[i] 를 만족하는 x를 고릅니다.
 * 3. i번째 box에서 x개 만큼의 빵을 꺼냅니다.(box[i] = box[i]-x)
 * 4. i-1번째 box에 꺼낸 x개 만큼의 빵을 넣습니다.(box[i-1] = box[i-1]+x)
 * 
 * 죠르디의 업무는 옮기는 과정이 끝난 후 모든 상자 중 가장 빵이 많은 상자에 든 빵의 개수가 가장적어지도록
 * 빵을 옮기는 일입니다.
 * 최종적으로 얻을수 있는 빵이 가장 많은 상자에 든 최소한의 빵 개수를 구하세요.
 * 
 * Ex1)
 * int n=4
 * int[] box={1,5,7,6}
 * result = 5
 * 
 * 최적의 옮기기 순서는 다음과 같습니다.(배열box는 1부터 시작합니다)
 * 	1. 첫번째 옮기기 : 
 * 		i=3, x=4 선택 (x는 1 <= 4 <= box[i] 를 만족합니다.
 * 		i 번째 박스에서 꺼낸 x개 만큼의 빵을 꺼냅니다.(7-4=3)
 * 		i-1 번째 박스에 꺼낸 x개 만큼의 빵을 넣습니다. (5+4=9)
 * 	2. 두번째 옮기기 :
 * 		i=2, x=4 선택
 * 		i 번째 박스에서 꺼낸 x개 만큼의 빵을 꺼냅니다.(9-4=5)
 * 		i-1 번째 박스에 꺼낸 x개 만큼의 빵을 넣습니다. (1+4=5)
 * 		배열 box는 이제 [5,5,3,6]이 되었습니다.(빵이 가장 많은 상자의 빵 개수는 6입니다.)
 * 	3. 두번째 옮기기 :
 * 		i=4, x=1 선텍
 * 		옮긴후 결과는 [5,5,4,5] 입니다. (빵이 가장 많은 상자의 빵 개수는 5입니다.)
 * 
 * Ex2)
 * int n=3
 * int[] box{5,15,19}
 * result = 13
 * 
 *  1. 첫번째 옮기기 : i=3, x=6 -> [5,21,13] 
 *  2. 두번째 옮기기 : i=2, x=8 -> [13,13,13]
 * 
 * Ex3)
 * int n=4
 * int[] box{10,3,5,7}
 * result = 10
 * 
 * 이 경우 옮기는 행동으로 가장 많은 상자에 든 최소한의 빵 개수를 줄일방법은 없습니다.
 * 
 * 2<=i<=n 을 만족하는 i를 고릅니다. <-- 여기서 탈락
 */

/**
 * 이런 유형은 처음인데..?
 * 
 */

public class Test3 {

	public static void main(String[] args) {

		// 상자의 갯수
		int n = 4;
		// 상자배열
		int[] box = {1,5,7,6};
		
		System.out.println(solution(n, box));

	}

	private static char[] solution(int n, int[] box) {
		
		return null;
	}
	

}
